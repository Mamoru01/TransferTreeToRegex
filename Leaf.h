#ifndef LEAF_H
#define LEAF_H

/*!
* \file      Leaf.h
* \brief     Классы узла листа для построения синтаксического дерева 
* \author    Зубков Александр Владимирович (zubkov.alexander.v@gmail.com)
* \version   0.01(development)
* \data      29 мая 2018 
*/
#include "ExprNode.h"


/*!
* <h1>Класс узла "Лист" синтаксического дерева</h1>
* <h2>Значения, которое может приминать данный узел:</h2>
* - символ, который не является служебным;
* - символьный класс;
* - утверждение;
* - meta-символ точки;
* - escape-символ;
* - последовательность;<br>
* Всё что не входит в текущий список является ошибкой!
*/
class Leaf:public ExprNode
{
	Q_OBJECT

	private : 
		QString leafOperand;

	public :
		/*!
		* Собрать текущий узел - "лист", учитывая ошибки построения.
		* \param[in] oper - значение текущего узла 
		* \param[out] error - ошибки при построении узла 
		*/
		Leaf(QString oper,QStringList & error);

		/*!
		* Собрать текущий узел - "лист",не учитывая ошибки построения.
		* \param[in] oper - значение текущего узла 
		*/
		Leaf(QString oper);
		
		/*!
		* Определить приоритет текущего класса.
		* \return наименьший приоритет равный "1". 
		*/
		int precedence();

		/*!
		* Собрать текст регулярного выражения текущего узла.
		* \param[in] prec - приоритет родительского узла
		* \return строку эквивалентную текущему узлу на языке регулярных выражения. 
		*/
		QString createText(int prec);

		/*!
		* Тип текущего узла для построения дерева.
		* \return строку эквивалентную текущему узлу на языке регулярных выражения. 
		*/
		QString type();

		/*!
		* Текст текущий узла
		* \return собранную строку текущего узла . 
		*/
		QString get_node();
};

#endif // LEAF_H